// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Recipe model stores all recipe information
model Recipe {
  id                 String   @id @default(cuid())
  name               String
  ingredients        String   // Stored as text, one ingredient per line (kept for backwards compatibility)
  proteinType        String?  // chicken, fish, red-meat, vegetarian
  carbType           String?  // rice, pasta, couscous, fries, other
  vegetableType      String?
  recipeUrl          String?  // link to URL if exists
  prepTime           String?  // quick, medium, long
  tier               String   // favorite, non-regular, new
  isLunchAppropriate Boolean  @default(false) // Whether this recipe is suitable for lunch
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relationship: A recipe can appear in multiple meal plans
  proteinMealPlans   MealPlan[] @relation("ProteinRecipe")
  carbMealPlans      MealPlan[] @relation("CarbRecipe")
  vegetableMealPlans MealPlan[] @relation("VegetableRecipe")
  lunchMealPlans     MealPlan[] @relation("LunchRecipe")

  // Relationship: A recipe has many structured ingredients
  structuredIngredients Ingredient[]
}

// Ingredient model stores structured ingredient data for recipes
model Ingredient {
  id        String   @id @default(cuid())
  recipeId  String
  name      String   // The ingredient name (e.g., "chicken breast", "olive oil")
  quantity  String?  // The amount (e.g., "2", "1/2", "500")
  unit      String?  // The unit of measurement (e.g., "cups", "grams", "tablespoons")
  notes     String?  // Additional notes (e.g., "diced", "optional", "for garnish")
  order     Int      // Display order in the recipe
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationship: Each ingredient belongs to one recipe
  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@index([recipeId])
}

// MealPlan model stores weekly meal plans
model MealPlan {
  id                String   @id @default(cuid())
  date              DateTime // The date for this meal
  dayOfWeek         String   // Monday, Tuesday, etc. (for display)
  lunchRecipeId     String?
  proteinRecipeId   String?
  carbRecipeId      String?
  vegetableRecipeId String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relationship: Each meal plan references recipes
  lunchRecipe     Recipe? @relation("LunchRecipe", fields: [lunchRecipeId], references: [id], onDelete: Cascade)
  proteinRecipe   Recipe? @relation("ProteinRecipe", fields: [proteinRecipeId], references: [id], onDelete: Cascade)
  carbRecipe      Recipe? @relation("CarbRecipe", fields: [carbRecipeId], references: [id], onDelete: Cascade)
  vegetableRecipe Recipe? @relation("VegetableRecipe", fields: [vegetableRecipeId], references: [id], onDelete: Cascade)

  // Index for efficient querying by date
  @@index([date])
}

// ShoppingList model stores generated shopping lists for a week
model ShoppingList {
  id        String   @id @default(cuid())
  weekStart DateTime // The Monday of the week this list is for
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationship: A shopping list has many items
  items ShoppingListItem[]

  // Ensure only one list per week
  @@unique([weekStart])
}


// ShoppingListItem model stores individual items on a shopping list
model ShoppingListItem {
  id             String   @id @default(cuid())
  shoppingListId String
  name           String   // The ingredient name (aggregated/normalized)
  quantity       String?  // Combined quantity (e.g., "3" or "2 + 1/2")
  unit           String?  // The unit (when units match during aggregation)
  notes          String?  // Source recipes or additional notes
  checked        Boolean  @default(false) // Whether item has been purchased
  source         String   @default("meal") // Item source: 'meal' | 'staple' | 'restock' | 'manual'
  order          Int      // Display order
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationship: Each item belongs to one shopping list
  shoppingList ShoppingList @relation(fields: [shoppingListId], references: [id], onDelete: Cascade)

  @@index([shoppingListId])
}

// Category model for grouping master list items by store section
model Category {
  id        String   @id @default(cuid())
  name      String   @unique // e.g., "Fresh Produce", "Pantry", "Dairy & Eggs"
  order     Int      // Display order
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationship: A category has many master list items
  items MasterListItem[]
}

// MasterListItem model stores staples and restock items (unified table)
model MasterListItem {
  id         String   @id @default(cuid())
  name       String   // Product name (e.g., "Sainsbury's British Free Range Eggs Large x12")
  type       String   // 'staple' | 'restock'
  categoryId String
  order      Int      // Display order within category
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relationship: Each item belongs to one category (Restrict = can't delete category with items)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)

  @@index([categoryId])
  @@index([type])
}

// DishType model stores dynamic protein and carb types
model DishType {
  id        String   @id @default(cuid())
  value     String   // e.g., "chicken", "rice" (used in Recipe.proteinType/carbType)
  label     String   // e.g., "Chicken", "Rice" (displayed in UI)
  category  String   // "protein" | "carb"
  order     Int      // Display order within category
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique constraint: no duplicate values within same category
  @@unique([category, value])
  @@index([category])
}
